\section{Reliability and Maintainability}

Our approach to reliability and maintainability took its cue from the
purpose of the system.

The purpose of the system:

\begin{itemize}
\item On one level, to explore a design for an adaptable cookery book.
\item On another level, to serve as a focus for building and
  demonstrating an understanding of techniques used for evaluating and
  improving interactive systems.
\end{itemize}

These purposes place the engineering of the system as a peripheral
concern: it is important that the system be sufficiently well-built
that it is easy to modify and doesn't fall over while being evaluated,
but making an application which is bulletproof in the face of
malicious user input and whose code crackles with craftsmanship would
be misspent effort.

Given this, we have generally followed lightweight processes intended
to produce a reasonably robust and maintainable system without
impeding the flexibility required to address the interaction design
and usability focus of the assessment.

\subsection{Coding Standards}

When writing the code, we followed a number of principles to aid in
ensuring reliability and maintainability.

\paragraph{Naming}
We have striven to follow a consistent naming scheme for classes,
functions, and variables. This reduces mental overhead and confusion
when working with the code, improving maintainability.

\paragraph{Consistent formatting}
Similarly, we have followed a consistent formatting convention
(enforced by tools) when working on the codebase. As with naming, this
reduces mental overhead and confusion when working with the code,
improving maintainability.

\paragraph{Commentary}
All of the files, classes, and functions we have written have PHPDoc
comments explaining them. This documentation is critical for
maintainability; it also helps reliability, as the need to explain
the code requires that it be well-understood. In addition, the
principal IDE we used (PHPStorm) can take advantage of PHPDoc comments
to provide more complete type checking, further improving reliability.

\paragraph{Fragile PHP features}
PHP has a number of `advanced' features (and some misfeatures) whose
use adversely affects the reliability and maintainability of a
codebase. For example: the \verb!__get! and \verb!__set! magic methods
and other reflection tools, while occasionally very powerful, make it
much more difficult to understand a codebase; references have
straightforwardly weird semantics that make their use very
error-prone; and the reference-by-name behaviour associated with
\verb!$$! etc. makes it very difficult to understand behaviour.

By avoiding the use of these features, we have improved the
reliability and maintainability of our system by avoiding the
surprising and error-prone `mysterious action at a distance' they
cause.

\paragraph{Immutable domain objects}

\subsection{CSS Preprocessing}

CSS is missing a number of abstraction features which are important in
keeping stylesheets maintainable, such as the ability to define
variables (for colours, sizes, etc), and functional units (such as
margin-based block centring). To improve the maintainability of our
system, we used the Sass CSS preprocessor\todo{reference} to generate
pure CSS from our more-maintainable SCSS stylesheets.

\subsection{Version Control}

\subsubsection{Choice of \texttt{git} over Subversion}

Although a Subversion repository was provided for our use by the
department, we chose to use a more modern version control tool,
\texttt{git}. The principal reasons for this were as follows:

\begin{itemize}
\item Data integrity: particularly in the hands of inexperienced
  users, subversion is prone to unrecoverably tangling the metadata it
  holds on the working copy, leading to data loss.
\item Team fit: our team is inherently distributed, only
  intermittently working colocated, a natural fit for the distributed
  model of git.
\item Safe merging: large merges (such as those which would be
  produced by our team structure) are especially fraught under
  subversion, as it merges the repository onto an uncommitted working
  copy; if the merge goes awry, the working-copy changes can be lost
  or mangled.
\item Availability: systems hosted on campus and in the department
  have not, historically, been entirely issue-free, particularly as
  load increases in the run-up to assessment submissions.
\end{itemize}

\subsubsection{Version control process}

Given the small size of the project, we opted for a lightweight
version control process. Most of the time, we worked on the
\texttt{master} branch, synchronising frequently with a remote
database---essentially just a robust implementation of a simple
centralised workflow, as would be used with subversion. Given the
relative inexperience of the team, we largely eschewed `advanced'
features such as feature branching, history rewriting, or directly
synchronising between working copies. However, all of these features
proved useful at various points to resolve specific issues.

In specific instances, for more complex and sweeping changes, we used
a slightly more rigorous process, working in dedicated branches which
were subsequently reviewed and merged using GitHub's pull request
system\todo{reference GitHub flow}.

In practice, we were satisfied most of the time with a simple
no-branching centralised model. It was very useful, however, to have
seamless access to more powerful tools in specific situations.

Our version control process, although simple, establishes a clear
audit trail for the codebase; this greatly improves the
maintainability of the system by allowing future developers to
understand the history of, and rationale for, each piece of
functionality, and provides a valuable source of additional
documentation.

\subsection{Issue Tracking}

\subsubsection{Choice of Issue Tracking tool}

We used GitHub's issue issue tracking system. GitHub was already a
natural place to host the principal copy of our repository, and their
issue tracking tool is simple but reasonably full-featured, and
has good repository integration.

\subsubsection{Issue Tracking process}

We made extensive use of our issue tracking tool to keep track of bugs
and outstanding work.

At specific points in the development cycle---particularly prior to
each stage of evaluation---we used milestones to collate issues and
ensure that we went into each evaluation with the system in a known,
well-defined state.

Our issue tracking process has contributed significantly to the
reliability of the system by ensuring that no work `fell through the
cracks', and that no bugs, once identified, went unfixed.

If we (or someone else with access to our issue tracking system) were
to continue developing the system, our issue tracking process would
also contribute significantly to maintainability, providing
documentation and a rationale for much of the work done, and a
powerful insight into the system.

\subsection{Data Model}

\subsubsection{Sample data}

To allow flexibility in the data model and database schema used, we
wrote some small scripts that would take take naturalistic YAML
descriptions of recipes (basically a one-to-one translation of the
provided sample recipes) and populate the database from them. This
made it easy to drop and recreate the database as we experimented with
and refactored the data model.

\subsubsection{Challenges imposed by CodeIgniter}

For the sake of consistency, we decided to use CodeIgniter as a
starting point. This turned out to introduce some issues that we had
to work around.

\begin{itemize}
\item CodeIgniter's `Active Record' facilities are actually a kind of
  pseudo-singleton Data Mapper, and actively inhibit using the Active
  Record pattern (which we wanted to for its simplicity). Fortunately,
  this can be fudged by borrowing a reference to the CodeIgniter
  database module, which is just a global property of the underlying
  CodeIgniter singleton anyway.
\item CodeIgniter's idiosyncratic loading schemes impose a moderately
  weird naming convention, and, more problematically, we weren't
  confident that they would interact nicely with modern class
  autoloading; we decided to fall back to bare \texttt{require}.
\end{itemize}

\subsubsection{DB-side data model}

\subsubsection{PHP-side data model}

\subsubsection{JS-side data model}

\subsubsection{Active Record}

\subsubsection{Lazy Loading}

\subsection{Testing}

Mostly informal acceptance testing.

\subsubsection{Acceptance Testing}

\paragraph{Acceptance Testing Approach}

\paragraph{Acceptance Test Procedures}

\subsubsection{Integration Testing}

As noted above, most of the testing was acceptance testing of some
form. However, there is still a place for some lightweight integration
testing to catch casual errors.

Our integration tests take the form of some very minimal smoke tests
that check that the various URLs associated with our application are
\begin{inparaenum}[\itshape a\upshape)]
\item reachable and
\item do not contain any obvious errors emitted by the PHP interpreter
\end{inparaenum}.

These goals are met by \verb!app/test/smoke.sh!, which does the
obvious things with \texttt{wget}, \texttt{grep}, etc., to check these
properties for a sample of the significant URLs in our application.

Obviously, these tests won't catch any errors of substance, but make
it easier to avoid inadvertently breaking things while refactoring
etc.

\subsubsection{Unit Testing}

Some form of unit-level testing is a fundamental part of any
engineering process. There are reasonably standard approaches to
software unit testing; however, the classic approach is made awkward
by:
\begin{inparaenum}[\itshape a\upshape)]
\item complex CodeIgniter dependencies and class loading
\item tight coupling to the database
\end{inparaenum}.
It isn't really worth pursuing the database coupling in the face of
the challenges caused by CodeIgniter and the small amount of logic
currently present in the model layer.

The compromise solution we've arrived at is a web page, part of the
CodeIgniter application, which when visited `runs' a number of tests
which sit somewhere between traditional unit tests and model/database
integration tests.  While a compromise, these tests do exercise most
of the functionality of the web application, catching a useful range
of issues and making the codebase easier to work with.
