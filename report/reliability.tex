\section{Reliability and Maintainability}

Our approach to reliability and maintainability took its cue from the
purpose of the system.

The purpose of the system:

\begin{itemize}
\item On one level, to explore a design for an adaptable cookery book.
\item On another level, to serve as a focus for building and
  demonstrating an understanding of techniques used for evaluating and
  improving interactive systems.
\end{itemize}

These purposes place the engineering of the system as a peripheral
concern: it is important that the system be sufficiently well-built
that it is easy to modify and doesn't fall over while being evaluated,
but making an application which is bulletproof in the face of
malicious user input and whose code crackles with craftsmanship would
be misspent effort.

Given this, we have generally followed lightweight processes intended
to produce a reasonably robust and maintainable system without
impeding the flexibility required to address the interaction design
and usability focus of the assessment.

\subsection{Coding Standards}

When writing the code, we followed a number of principles to aid in
ensuring reliability and maintainability.

\paragraph{Naming}
We have striven to follow a consistent naming scheme for classes,
functions, and variables. This reduces mental overhead and confusion
when working with the code, improving maintainability.

\paragraph{Consistent formatting}
Similarly, we have followed a consistent formatting convention
(enforced by tools) when working on the codebase. As with naming, this
reduces mental overhead and confusion when working with the code,
improving maintainability.

\paragraph{Commentary}
All of the files, classes, and functions we have written have PHPDoc
comments explaining them. This documentation is critical for
maintainability; it also helps reliability, as it requires a clear
understanding of the purpose of the code, which demands simple,
clearly-written code.

\paragraph{Fragile PHP features}
We were careful to avoid some of the easy-to-misuse features of PHP,
such as the \verb!__get! and \verb!__set! magic methods, references
(because of the weird way they taint the symbol table), \verb!$$!, etc.

Doing this has improved the reliability and maintainability of our
system by avoiding the surprising and error-prone `mysterious action
at a distance' they cause.

\subsection{CSS Preprocessing}

CSS is missing a number of abstraction features which are important in
keeping stylesheets maintainable, such as the ability to define
variables (for colours, sizes, etc), and functional units (such as
margin-based block centring). To improve the maintainability of our
system, we used the Sass CSS preprocessor\todo{reference} to generate
pure CSS from our more-maintainable SCSS stylesheets.

\subsection{Version Control}

\subsubsection{Choice of \texttt{git} over Subversion}

Although a Subversion repository was provided for our use by the
department, we chose to use a more modern version control tool,
\texttt{git}. The principal reasons for this were as follows:

\begin{itemize}
\item Data integrity: with inexperienced users, subversion can be
  fragile and occasionally trashes its working-copy metadata.
\item Team fit: our team is inherently distributed and mostly works
  separately, a natural fit for git.
\item Safe merging: the git model of merging two commits is less
  fragile than the subversion model of merging the remote onto an
  uncommitted working copy, which can cause data loss.
\end{itemize}

\subsubsection{Version control process}

Given the small size of the project, we opted for a lightweight
version control process. Most of the time, we followed a centralised
workflow, as with subversion, as this was sufficient and appropriate
for the experience level of the team. For similar reasons, we mostly
eschewed `advanced' features such as feature branching, history
rewriting, etc.

In specific instances, for more complex and sweeping changes, we used
a slightly more rigorous process, working in dedicated branches which
were subsequently reviewed and merged using GitHub's pull request
system\todo{reference GitHub flow}.

In practice, we were satisfied most of the time with a simple
no-branching centralised model. It was very useful, however, to have
seamless access to the more powerful tools afforded by \textt{git} in
specific situations.

Our version control process, although simple, establishes a clear
audit trail for the codebase; this greatly improves the
maintainability of the system by allowing future developers to
understand the history of, and rationale for, each piece of
functionality, and provides a valuable source of additional
documentation.

\subsection{Issue Tracking}

\subsubsection{Choice of Issue Tracking tool}

We used GitHub's issue issue tracking system. GitHub was already a
natural place to host the principal copy of our repository, and their
issue tracking tool is simple but reasonably full-featured, and
has good repository integration.

\subsubsection{Issue Tracking process}

We made extensive use of our issue tracking tool to keep track of bugs
and outstanding work.

At specific points in the development cycle---particularly prior to
each stage of evaluation---we used milestones to collate issues and
ensure that we went into each evaluation with the system in a known,
well-defined state.

Our issue tracking process has contributed significantly to the
reliability of the system by ensuring that no work `fell through the
cracks', and that no bugs, once identified, went unfixed.

If we (or someone else with access to our issue tracking system) were
to continue developing the system, our issue tracking process would
also contribute significantly to maintainability, providing
documentation and a rationale for much of the work done, and a
powerful insight into the system.

\subsection{Sample data}

To allow flexibility in the data model and database schema used, we
wrote some small scripts that would take take naturalistic YAML
descriptions of recipes (basically a one-to-one translation of the
provided sample recipes) and populate the database from them. This
made it easy to drop and recreate the database as we experimented with
and refactored the data model.

This improves reliability by guaranteeing that the database will
contain no invalid data; it also improves maintainability, by making
it easy to refactor the database or extend that data model.

\subsection{Testing}

Most of the testing we did was effectively informal acceptance testing; because of
the amount of time we spent evaluating the website from a usability
and interaction-design perspective, w

\subsubsection{Integration Testing}

As noted above, most of the testing was acceptance testing of some
form. However, we found a place for some lightweight integration
testing to catch casual errors.

Our integration tests take the form of some very minimal smoke tests
that check that the various URLs associated with our application are
\begin{inparaenum}[\itshape a\upshape)]
\item reachable and
\item do not contain any obvious errors emitted by the PHP interpreter
\end{inparaenum}.

These goals are met by \verb!app/test/smoke.sh!, which uses basic unix
utilites to check these properties for the various important URLs in
the application.

Having these tests has helped to improve the reliability of the system
by making it easy to ensure a basic level of functionality across the
application. They also help with maintainability by allowing more
confident refactoring, acting as a safety net to catch heinous errors
early.


\subsubsection{Unit Testing}

Some form of unit-level testing is a fundamental part of any
engineering process. However, the complexity of CodeIgniter
initialisation and the tight coupling of our application to the
database make it awkward to use classic xUnit-style strongly-decoupled
tests.

Our compromise was a page within the CodeIgniter site (\verb!index.php/test!) which, when
visited, executes a number of simple tests which exercise the model
layer. Given the database coupling, these really sit somewhere between
unit and integration tests, but we felt this was acceptable given the
lightweight nature of our model layer. Rather than an in-depth and
exact verification of precise behaviour, these tests also function
more as smoke tests, making it easy to exercise the whole of the model
layer at once to catch a broader range of model-layer issues than the
integration tests above.

These tests have increased reliability by ensuring that the model
layer works, and increase maintainability by allowing us to make
changes with confidence.
