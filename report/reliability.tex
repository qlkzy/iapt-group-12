\section{Reliability and Maintainability}

Our approach to reliability and maintainability took its cue from the
purpose of the system.

The purpose of the system:

\begin{itemize}
\item On one level, to explore a design for an adaptable cookery book.
\item On another level, to serve as a focus for building and
  demonstrating an understanding of techniques used for evaluating and
  improving interactive systems.
\end{itemize}

These purposes place the engineering of the system as a peripheral
concern: it is important that the system be sufficiently well-built
that it is easy to modify and doesn't fall over while being evaluated,
but making an application which is bulletproof in the face of
malicious user input and whose code crackles with craftsmanship would
be misspent effort.

\subsection{Coding Standards}

\subsubsection{General PHP Coding Standards}

\subsubsection{Project-Specific Coding Standards}

\begin{itemize}
\item Naming, indentation, etc.
\item Commentary.
\item No use of magic methods (\verb!__get! \verb!__set! et al) in our
  code (CodeIgniter makes limited use)
\item No use of PHP references in our code.
\item Minimise use of raw mutation methods, preferring `real' OO.
\end{itemize}

\subsection{Tool Support}

\subsubsection{PHP CodeSniffer}

\subsubsection{PHP Mess Detector}

\subsubsection{HTML CodeSniffer}

\subsubsection{PHPStorm Inspection Tools}

\subsubsection{SCSS}

\subsection{Version Control}

\subsubsection{Choice of \texttt{git} over Subversion}

Although a Subversion repository was provided for our use by the
department, we chose to use a more modern version control tool,
\texttt{git}. The principal reasons for this were as follows:

\begin{itemize}
\item Data integrity: particularly in the hands of inexperienced
  users, subversion is prone to unrecoverably tangling the metadata it
  holds on the working copy, leading to data loss.
\item Team fit: our team is inherently distributed, only
  intermittently working colocated, a natural fit for the distributed
  model of git.
\item Safe merging: large merges (such as those which would be
  produced by our team structure) are especially fraught under
  subversion, as it merges the repository onto an uncommitted working
  copy; if the merge goes awry, the working-copy changes can be lost
  or mangled.
\item Availability: systems hosted on campus and in the department
  have not, historically, been entirely issue-free. Given the
  importance of the assessment, it was felt that not introducing
  departmental IT services as a single point of failure was the
  prudent course.
\item Does it \textit{look} like 2002?
\end{itemize}

\subsubsection{Version control process}

\begin{itemize}
\item Branching
\item Pull requests
\item Somewhat flexible, heavy-duty collaboration process only
  intermittently needed.
\end{itemize}

\subsection{Issue Tracking}

\subsubsection{Choice of Issue Tracking tool}

We used GitHub's issue issue tracking system. GitHub was already a
natural place to host the principal copy of our repository, and their
issue tracking tool is simple but reasonably full-featured, and
has good repository integration.

\subsubsection{Issue Tracking process}

Issues

Milestones

Ended up not relying much on repository integration.

\subsection{Data Model}

\subsubsection{Sample data}

To allow flexibility in the data model and database schema used, we
wrote some small scripts that would take take naturalistic YAML
descriptions of recipes (basically a one-to-one translation of the
provided sample recipes) and populate the database from them. This
made it easy to drop and recreate the database as we experimented with
and refactored the data model.

\subsubsection{Challenges imposed by CodeIgniter}

For the sake of consistency, we decided to use CodeIgniter as a
starting point. This turned out to introduce some issues that we had
to work around.

\begin{itemize}
\item CodeIgniter's `Active Record' facilities are actually a kind of
  pseudo-singleton Data Mapper, and actively inhibit using the Active
  Record pattern (which we wanted to for its simplicity). Fortunately,
  this can be fudged by borrowing a reference to the CodeIgniter
  database module, which is just a global property of the underlying
  CodeIgniter singleton anyway.
\item CodeIgniter's idiosyncratic loading schemes impose a moderately
  weird naming convention, and, more problematically, we weren't
  confident that they would interact nicely with modern class
  autoloading; we decided to fall back to bare \texttt{require}.
\end{itemize}

\subsubsection{DB-side data model}

\subsubsection{PHP-side data model}

\subsubsection{JS-side data model}

\subsubsection{Active Record}

\subsubsection{Lazy Loading}

\subsection{Testing}

Mostly informal acceptance testing.

\subsubsection{Acceptance Testing}

\paragraph{Acceptance Testing Approach}

\paragraph{Acceptance Test Procedures}

\subsubsection{Integration Testing}

As noted above, most of the testing was acceptance testing of some
form. However, there is still a place for some lightweight integration
testing to catch casual errors.

Our integration tests take the form of some very minimal smoke tests
that check that the various URLs associated with our application are
\begin{inparaenum}[\itshape a\upshape)]
\item reachable and
\item do not contain any obvious errors emitted by the PHP interpreter
\end{inparaenum}.

These goals are met by \verb!app/test/smoke.sh!, which does the
obvious things with \texttt{wget}, \texttt{grep}, etc., to check these
properties for a sample of the significant URLs in our application.

Obviously, these tests won't catch any errors of substance, but make
it easier to avoid inadvertently breaking things while refactoring
etc.

\subsubsection{Unit Testing}

Some form of unit-level testing is a fundamental part of any
engineering process. There are reasonably standard approaches to
software unit testing; however, the classic approach is made awkward
by:
\begin{inparaenum}[\itshape a\upshape)]
\item complex CodeIgniter dependencies and class loading
\item tight coupling to the database
\end{inparaenum}.
It isn't really worth pursuing the database coupling in the face of
the challenges caused by CodeIgniter and the small amount of logic
currently present in the model layer.

The compromise solution we've arrived at is a web page, part of the
CodeIgniter application, which when visited `runs' a number of tests
which sit somewhere between traditional unit tests and model/database
integration tests.  While a compromise, these tests do exercise most
of the functionality of the web application, catching a useful range
of issues and making the codebase easier to work with.
